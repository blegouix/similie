<!--
SPDX-FileCopyrightText: 2024 Baptiste Legouix
SPDX-License-Identifier: MIT
-->

# FunctorEvaluatorByOrderedIndices + Cython example

This minimal example shows how to build a Cython functor that can be consumed from C++ through `sil::misc::FunctorEvaluatorByOrderedIndices`.

## 1. Cython functor (`cython_functor.pyx`)

```cython
from libc.stdlib cimport malloc, free

cdef class CythonFunctor:
    cdef double factor

    def __cinit__(self, double factor):
        self.factor = factor

    cpdef double __call__(self, int x, int y, int z):
        return self.factor * (100.0 * z + 10.0 * y + x)


# Expose a plain C factory returning an owning pointer so C++ can hold it.
cdef extern from *:
    """
    struct CythonFunctorHandle {
        CythonFunctor* ptr;
    };
    """
    struct CythonFunctorHandle:
        CythonFunctor* ptr


cdef CythonFunctorHandle* allocate_functor(double factor):
    cdef CythonFunctorHandle* handle = <CythonFunctorHandle*>malloc(sizeof(CythonFunctorHandle))
    handle.ptr = CythonFunctor(factor)
    return handle


cpdef CythonFunctorHandle* cython_functor_create(double factor):
    return allocate_functor(factor)

cpdef void cython_functor_destroy(CythonFunctorHandle* handle):
    if handle is not NULL:
        del handle.ptr
        free(handle)
```

## 2. Build the extension (`setup.py`)

```python
from setuptools import setup
from setuptools.extension import Extension
from Cython.Build import cythonize

extensions = [
    Extension(
        name="cython_functor",
        sources=["cython_functor.pyx"],
        language="c++",
    ),
]

setup(
    name="cython-functor-example",
    ext_modules=cythonize(extensions, language_level="3"),
)
```

Build the module:

```bash
python -m pip install .  # or: python setup.py build_ext --inplace
```

## 3. Use it from C++

```cpp
#include <memory>
#include <ddc/ddc.hpp>
#include <similie/misc/discrete_element_evaluator.hpp>

struct DDimX {};
struct DDimY {};
struct DDimZ {};
using domain_t = ddc::DiscreteDomain<DDimX, DDimY, DDimZ>;

// Declarations generated by Cython (from cython_functor.cpp)
extern "C" {
    struct CythonFunctorHandle;
    CythonFunctorHandle* cython_functor_create(double factor);
    void cython_functor_destroy(CythonFunctorHandle* handle);
    double __pyx_pw_14cython_functor_14CythonFunctor___call__(
            CythonFunctorHandle* self, int x, int y, int z);
}

struct CythonFunctorWrapper {
    CythonFunctorHandle* handle;

    ~CythonFunctorWrapper() { cython_functor_destroy(handle); }

    double operator()(int x, int y, int z) const
    {
        return __pyx_pw_14cython_functor_14CythonFunctor___call__(handle, x, y, z);
    }
};

int main()
{
    CythonFunctorWrapper functor{cython_functor_create(0.5)};
    sil::misc::FunctorEvaluatorByOrderedIndices<domain_t, CythonFunctorWrapper> evaluator(functor);
    ddc::DiscreteElement<DDimX, DDimY, DDimZ> elem(52, 34, 1);
    double value = evaluator(elem); // value == 246.0
    (void)value;
}
```

This pattern keeps the Cython-owned functor alive via the wrapper and forwards ordered indices to it using `FunctorEvaluatorByOrderedIndices`.
